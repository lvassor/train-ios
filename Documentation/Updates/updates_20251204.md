# Strength Training App — Development Tasks

## Context

This is an iOS strength training app built in Swift. We're currently in MVP phase using local Core Data storage, with plans to migrate to a cloud database (likely Supabase) post-MVP for scalability and potential Android expansion.

---

## Task 1: Data Architecture Analysis & Recommendation

**Priority: High — this informs other tasks**

### What I need

Perform a comprehensive analysis of our data storage architecture, examining:

1. **Current state**: Review `WorkoutLogView.swift` to understand what data we currently capture during a workout (sets, reps, load, etc.)

2. **Program structure**: Analyze how we generate and store training programs, specifically:
   - Users are assigned a split (e.g., Push/Pull/Legs = 3 sessions per week)
   - Each session type has different exercises
   - Each user needs separate data stores for each day in their split
   - We support variable split lengths (3-day, 4-day, 5-day, etc.)

3. **New feature consideration**: We want to add the ability for users to add a note at the end of each workout session

4. **Data points to map**:
   - Program generation inputs (from questionnaire)
   - Program structure (splits, sessions, exercises per session)
   - Workout log data (per set: reps, load, completion status; per session: date, duration, notes)
   - Exercise metadata (from exercise database)

### Deliverable

Provide a written analysis covering:

- Current data model assessment
- Recommended schema design for Core Data (MVP)
- How this schema would translate to a relational cloud database (Supabase/PostgreSQL)
- Any considerations for future Android compatibility
- Entity relationship diagram or clear schema documentation
- Recommendation on relational vs non-relational (with justification)

---

## Task 2: Exercise Database SQL Schema Update

**Priority: High**

### Context

We have an existing SQL schema for exercises and a new Excel-based exercise database with an updated structure. The new database (new_exercise_db.xlsx - analyse this) includes:

**Main table columns:**
- `exercise_id` (e.g., EX001)
- `canonical_name` (movement pattern grouping, e.g., "Squat" — used for exercise swapping)
- `display_name` (what users see)
- `equipment_name` (e.g., Barbell, Dumbbell, Leg Press)
- `equipment_type` (Pin-Loaded, Plate-Loaded, Cable — used for machine variants)
- `accessory_equipment` (e.g., Cable Attachment, Bench)
- `complexity_level` (1-4 or "iso")
- `primary_muscle`
- `secondary_muscle`
- `instructions`
- `is_active`

**Lookup tables for:**
- Canonical exercise names (27 values)
- Complexity levels (1, 2, 3, 4, iso)
- Muscles (15 values)
- Equipment names (20 values)
- Equipment types (3 values)
- Accessory equipment (12 values)

### Deliverable

1. Review the existing SQL schema in the codebase
2. Design a new SQL schema that accommodates the updated exercise database structure
3. Include proper foreign key relationships to lookup tables
4. Ensure the schema supports:
   - Filtering exercises by equipment the user has available
   - Swapping exercises within the same canonical group (navigate to the swap feature in the workout logger to understand this)
   - Filtering by complexity level based on user experience
   - Filtering by muscle group for program generation
5. Provide the complete SQL CREATE TABLE statements
6. Note any migration considerations from old to new schema
7. Note that we don't necesssarily need to import the lookup tables as part of the database, those look ups were mainly just to enforce data quality controls on the main spreadsheet - we can keep the first sheet in the xlsx as a csv and use that.
---

## Task 3: Experience Level Question Redesign

**Priority: Medium**

### Current behaviour

We ask users how long they've been training and bucket them by time:
- Complete beginner
- 0-6 months
- 6 months - 2 years
- etc.

### Problem

Time-based bucketing doesn't account for confidence. Someone might have trained for years but still lack confidence, or be a natural who's confident after 3 months.

### New approach

Change to confidence-based self-assessment with 4 levels. Each option needs:
- A clear title
- Friendly, non-judgmental subheading text that helps users self-identify without feeling bad about their level

### Important: Keep existing complexity mappings

The current time-based buckets already map to complexity scores that determine which exercises users see. **Do not change these complexity assignments.** Simply map the existing 4 time-based levels to the new 4 confidence-based levels:

| Old (Time-Based) | New (Confidence-Based) | Complexity Score |
|------------------|------------------------|------------------|
| Complete beginner | → New Level 1 copy | (keep same) |
| 0-6 months | → New Level 2 copy | (keep same) |
| 6 months - 2 years | → New Level 3 copy | (keep same) |
| 2+ years | → New Level 4 copy | (keep same) |

### Deliverable

Write the copy for 4 experience levels with:
- Title (short, e.g., "Complete Beginner")
- Subheading (1-2 sentences, warm and inviting tone)
- Map each level to the existing complexity score assignments (check the current codebase for these values)

Example tone: "No worries if you're just starting out — everyone begins somewhere, and we'll make sure you're set up with exercises that build your confidence."

---

## Task 4: Equipment Availability Question — Expandable Detail

**Priority: Medium**

### Current behaviour

Users select broad equipment categories they have access to (e.g., "Barbells", "Pin-loaded machines", "Plate-loaded machines")

### New behaviour

When a user selects certain categories, they should be able to expand that selection to see specific equipment items within that category, with checkboxes to include/exclude specific pieces.

### Categories that need expansion

**Barbells** — expand to show:
- Squat rack
- Flat bench press
- Incline bench press
- Decline bench press
- (any other barbell-specific stations from the database)

**Pin-loaded machines** — expand to show all pin-loaded equipment from database:
- Lat pulldown
- Seated cable row
- Chest press machine
- Pec deck / chest fly
- Leg press (pin-loaded)
- Leg extension (pin-loaded)
- Lying leg curl (pin-loaded)
- Seated leg curl (pin-loaded)
- Standing calf raise (pin-loaded)
- Seated calf raise (pin-loaded)
- Hip abduction
- Hip adduction
- (etc.)

**Plate-loaded machines** — expand to show all plate-loaded equipment:
- Leg press (plate-loaded)
- Hack squat
- Leg extension (plate-loaded)
- Lying leg curl (plate-loaded)
- Seated leg curl (plate-loaded)
- Standing calf raise (plate-loaded)
- Seated calf raise (plate-loaded)
- Chest supported row
- T-bar row
- (etc.)

### Deliverable

1. Query the exercise database and extract the complete list of unique equipment that falls under:
   - Barbell exercises (what stations/benches are implied)
   - Pin-loaded machines (from `equipment_type` = 'Pin-Loaded')
   - Plate-loaded machines (from `equipment_type` = 'Plate-Loaded')
   
2. Provide the complete list organised by category

3. Implement the expandable UI component:
   - Collapsed state: shows category with checkmark
   - Expanded state: shows all items within category with individual checkmarks
   - Parent checkbox behaviour: checking/unchecking parent affects all children
   - Mixed state: if some children unchecked, parent shows mixed indicator

4. Update the data model to store granular equipment selections

---

## Task 5: Rest Timer UX Redesign

**Priority: Medium**

### Current behaviour

When a user marks a set as complete, a rest timer appears as a full-screen overlay. This blocks all other app interaction until the timer completes or is dismissed.

### Problem

Users can't do anything else while the timer runs (e.g., check upcoming exercises, review notes, scroll through their workout).

### New behaviour

Replace the overlay with an inline timer that appears within the exercise card:

**Placement:**
- Timer appears at the top of the exercise logger card
- Positioned below the set/rep prescription text
- Above the first input row where they log their actual numbers

**Appearance:**
- Single row, styled like an accent color button
- Contains: circular progress indicator + time remaining in numbers
- Should feel like a persistent but non-intrusive element

**Behaviour:**
- Timer starts automatically when user marks a set complete
- If user completes another set while timer is running: timer resets and restarts
- When timer reaches zero: timer collapses/hides automatically
- User can still interact with everything else in the app while timer runs
- Optional: tap timer to dismiss early

### Deliverable

1. Remove the existing overlay timer component
2. Create new inline timer component with the specifications above
3. Integrate into the exercise card layout
4. Handle timer reset logic when new set is completed
5. Animate the expand/collapse of the timer row

---

## Task 6: Bug Fix — Number Pad Dismissal

**Priority: High (UX blocker)**

### Current behaviour

When users tap into the reps or load input fields:
- Number pad appears correctly (since these are integer fields)
- User enters their number
- There is no way to dismiss the number pad
- User is forced to navigate away from the exercise screen entirely to close it

### Expected behaviour

User should be able to dismiss the number pad while staying on the same screen.

### Possible solutions

1. **Tap outside to dismiss**: Tapping anywhere outside the input field dismisses the keyboard
2. **Done button**: Add a "Done" button to the keyboard toolbar (standard iOS pattern)
3. **Scroll to dismiss**: If the logger is scrollable, enable keyboard dismissal on scroll

### Deliverable

Implement keyboard dismissal for number pad inputs, using whichever approach best fits the existing UI patterns. Recommend option 2 (Done button toolbar) as it's the most explicit and iOS-native.

---

## Order of Operations

Recommended sequence for tackling these tasks:

1. **Task 1** (Data Architecture Analysis) — do this first as it informs schema decisions
2. **Task 2** (SQL Schema) — depends on understanding current data model
3. **Task 6** (Number Pad Bug) — quick win, high user impact
4. **Task 5** (Rest Timer) — medium complexity UI work
5. **Task 3** (Experience Level Copy) — can be done in parallel, mostly copywriting
6. **Task 4** (Equipment Expansion) — depends on final database schema

---

## Files to Reference

- `WorkoutLogView.swift` — current workout logging structure
- Existing SQL/Core Data schema files for exercises
- Questionnaire/onboarding flow files
- Exercise database Excel file (uploaded separately)
- Any existing timer component code

---

## Task 7: Charcoal Gradient Background — Fix Implementation

**Priority: Medium (Visual consistency)**

### Current behaviour

We attempted to implement a charcoal-style gradient background across the app, but it is not rendering anywhere. The background appears either as a solid colour or the default system background.

### Expected behaviour

A charcoal gradient background should be visible across full-screen view backgrounds, providing a consistent dark, modern aesthetic.

### Important: Background vs Material distinction

- **Full-screen view backgrounds** (Welcome, Login, Signup, Questionnaire, Dashboard, Workout Logger, etc.) → Use `charcoalGradientBackground()`
- **Scroll content / card views** (Profile/Account Settings, Library, Milestones, modal sheets) → Use `.ultraThinMaterial` with NO opacity modification

Do NOT apply the charcoal gradient to scroll content views or modals. Those should remain `.ultraThinMaterial` for the frosted glass effect.

### Deliverable

1. Create a new scheme in ColorPalettes.json called "Train Charcoal" with the diagonal gradient:
   - Light corner: #5E5E5E (medium gray, top-left)
   - Midpoint: #101010 (very dark gray, at 30% location)
   - Dark corner: #0B0B0B (near black, bottom-right)

2. Rename the view modifier from `warmDarkGradientBackground()` to `charcoalGradientBackground()` — no "warm" terminology

3. Apply `charcoalGradientBackground()` ONLY to full-screen view backgrounds:
   - WelcomeView
   - LoginView
   - SignupView
   - QuestionnaireView
   - DashboardView
   - WorkoutLoggerView / ExerciseLoggerView
   - ProgramReadyView
   - ProgramLoadingView
   - PaywallView

4. Keep `.ultraThinMaterial` for scroll/card views:
   - ProfileView (Account Settings)
   - CombinedLibraryView
   - MilestonesView
   - Modal sheets

5. Ensure the gradient works correctly with:
   - Safe area insets (extends to edges of screen)
   - Keyboard appearance (doesn't break when keyboard shows)

---

## Questions to Answer Back

After analysis, please report:

1. What is the current data model and what are its limitations?
2. What schema do you recommend and why?
3. Are there any blockers or ambiguities in these tasks that need clarification?
4. Estimated complexity for each task (low/medium/high)
5. Any technical debt or refactoring opportunities spotted during analysis
